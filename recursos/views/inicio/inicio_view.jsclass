view_index = {
	Extends : View,
	nodos : [],
	renderer : function(canvas) {
		var ctx = canvas.getContext("2d");
		var particleSystem

		var that = {
			init : function(system) {
				//
				// the particle system will call the init function once, right
				// before the
				// first frame is to be drawn. it's a good place to set up the
				// canvas and
				// to pass the canvas size to the particle system
				//
				// save a reference to the particle system for use in the
				// .redraw()
				// loop
				particleSystem = system

				// inform the system of the screen dimensions so it can map
				// coords
				// for us.
				// if the canvas is ever resized, screenSize should be called
				// again
				// with
				// the new dimensions
				particleSystem.screenSize(canvas.width, canvas.height)
				particleSystem.screenPadding(80) // leave an extra 80px of
				// whitespace per side

				// set up some event handlers to allow for node-dragging
				//that.initMouseHandling()
			},

			redraw : function() {
				// 
				// redraw will be called repeatedly during the run whenever the
				// node
				// positions
				// change. the new positions for the nodes can be accessed by
				// looking at the
				// .p attribute of a given node. however the p.x & p.y values
				// are in
				// the coordinates
				// of the particle system rather than the screen. you can either
				// map
				// them to
				// the screen yourself, or use the convenience iterators
				// .eachNode
				// (and .eachEdge)
				// which allow you to step through the actual node objects but
				// also
				// pass an
				// x,y point in the screen's coordinate system
				// 
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				particleSystem.eachNode(function(node, pt) {
					// node: {mass:#, p:{x,y}, name:"", data:{}}
					// pt: {x:#, y:#} node position in screen coords
					if(!node.data.model.dragging)
						node.data.model.setCenter(pt);
					
					// draw a rectangle centered at pt
					var w = 10;//Math.random()*50
					ctx.fillStyle = "white";
					ctx.fillRect(node.data.model.center.x - w / 2, node.data.model.center.y - w / 2, w, w)
				})
				
				particleSystem.eachEdge(function(edge, pt1, pt2) {
					// edge: {source:Node, target:Node, length:#, data:{}}
					// pt1: {x:#, y:#} source position in screen coords
					// pt2: {x:#, y:#} target position in screen coords

					// draw a line from pt1 to pt2
					ctx.strokeStyle = edge.data.model.target.getStrokeStyle();
					ctx.lineWidth = 5;//Math.random()*10
					ctx.beginPath()
					ctx.moveTo(edge.data.model.source.center.x, edge.data.model.source.center.y)
					ctx.lineTo(edge.data.model.target.center.x, edge.data.model.target.center.y)
					ctx.stroke()
				})
			},

			initMouseHandling_ : function() {
				// no-nonsense drag and drop (thanks springy.js)
				var dragged = null;

				// set up a handler object that will initially listen for
				// mousedowns
				// then
				// for moves and mouseups while dragging
				var handler = {
					clicked : function(e) {
						var pos = canvas.getPosition();
						_mouseP = arbor.Point(e.event.pageX - pos.x,
								e.event.pageY - pos.y)
						dragged = particleSystem.nearest(_mouseP);

						if (dragged && dragged.node !== null) {
							// while we're dragging, don't let physics move the
							// node
							dragged.node.fixed = true
						}

						canvas.addEvent('mousemove', handler.dragged)
						window.addEvent('mouseup', handler.dropped)

						return false
					},
					dragged : function(e) {
						var pos = canvas.getPosition();
						var s = arbor.Point(e.event.pageX - pos.x,
								e.event.pageY - pos.y)

						if (dragged && dragged.node !== null) {
							var p = particleSystem.fromScreen(s)
							dragged.node.p = p
						}

						return false
					},

					dropped : function(e) {
						if (dragged === null || dragged.node === undefined)
							return

						

						if (dragged.node !== null)
							dragged.node.fixed = false
						dragged.node.tempMass = 1000
						dragged = null
						// $(canvas).unbind('mousemove', handler.dragged)
						// $(window).unbind('mouseup', handler.dropped)
						_mouseP = null
						return false
					}
				}

				// start listening
				canvas.addEvent('mousedown', handler.clicked);
			},

		}
		return that
	},
	init : function() {
		this.getTheme('inicio');
	},
	menu : {
		name : 'Propgrama Provincial de Fertilizacion Asistida',
		childs : [ {
			name : 'Menu 1',
			childs : [ {
				name : 'Menu 11'
			}, {
				name : 'Menu 12'
			}, {
				name : 'Menu 13'
			} ]
		}, {
			name : 'Menu 2',
			type: 'itemMenuDebug',
			childs : [ {
				name : 'Menu 21'
			}, {
				name : 'Menu 22'
			}, {
				name : 'Menu 23'
			} ]
		}, {
			name : 'Menu 3',
			childs : [ {
				name : 'Menu 31'
			}, {
				name : 'Menu 32'
			}, {
				name : 'Menu 33'
			} ]
		} ]
	},
	parseMenu : function(node) {
		var chileNodes = [];
		if (node.childs){
			node.childs.each(function(childNode){
				chileNodes.push(this.parseMenu(childNode));
			}.bind(this));
		}
		var itemMenu = this.getModel((node.type)?node.type:'itemMenu',{name:node.name,sys: this.sys, childs: chileNodes});
		return itemMenu;
		itemMenu.setNode(pNode);
		var edge;
		chileNodes.each(function(chileNode) {
			edge = arbor.Edge(itemMenu.getNode(), chileNode.getNode(), {
				model : {
					source: itemMenu,
					target: chileNode
				}
			});
			itemMenu.connect({
				node : chileNode,
				edge : edge
			});
		}.bind(this))
		return itemMenu;
	},
	render : function() {
		this.canvas = $("inicio");
		window.addEvent('resize',this.resizeCanvas.bind(this));
		this.resizeCanvas(); 
		this.sys = arbor.ParticleSystem(1000, 600, 0.5) // create the system
		// with sensible
		// repulsion/stiffness/friction
		this.sys.parameters({stiffness:900, repulsion:2000, gravity:true, dt:0.015}) // use center-gravity to make the graph
		// settle nicely (ymmv)
		this.sys.renderer = this.renderer(this.canvas) // our newly created
		// renderer will have its
		// .init() method called
		// shortly by sys...
		this.tree = this.getModel((this.menu.type)?this.menu.type:'itemMenu',{
			name: this.menu.name,
			childs: this.menu.childs,
			sys: this.sys
		});
		this.tree.draw();
		this.tree.drawChilds();
	},
	resizeCanvas: function(){
		var size = this.canvas.getSize();
		this.canvas.setProperties({
		    width: size.x,
		    height: size.y
		});
	}
}